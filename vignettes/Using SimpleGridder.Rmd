---
title: "Using SimpleGridder: Gridding Environmental Data"
author: "Thomas Bryce Kelly"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using SimpleGridder}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Let's start with a working example to see how SimpleGridder works, what it does, and how the results look. If you don't have SimpleGridder installed already, it can be installed directly from Github using _devtools_: `devtools::install_github('tbrycekelly/SimpleGridder')`. 

```{r}
library(SimpleGridder)

## Make test data (x, y, z)
n = 10
x = runif(n)
y = runif(n)
z = x + y

## Use SimpleGridder to make grid
grid = buildGrid(xlim = c(0,1), ylim = c(0,1), nx = 100, ny = 100)
grid = setGridder(grid, neighborhood = 20)
grid = appendData(grid, x, y, z, 'salinity')
grid = interpData(grid)
plotGrid(grid, 'salinity')
```

Great, now we have a template to refer to as we (1) see what each step does, (2) what options we have (or don't have), and (3) review the applications for this package.

To generate an interpolated data product (i.e. gridding) there are X distinct steps, each of which you control in SimpleGridder:

1. Construct an idealized grid with the locations you want to interpolate (and extrapolate) your data to. 
2. Decide on an interpolation algorithm, for example nearest neighbor.
3. Prepare observations against which the interpolator will be applied.
4. Finally, generate your interpolated data product.

So why so many steps?

While conceptually simple, gridding observations entails a lot of assumptions, decisions, and complexity that you were likely (and perhaps luckily) unaware of until now. Let's take a look at each of these functions (and steps) in turn.

Starting wit hthe `buildGrid()` function, let's see what the grid data structure (a list) looks like. 
```{r echo=TRUE}
grid = buildGrid(xlim = c(0,1), ylim = c(0,1), nx = 100, ny = 100)
str(grid)
```
Overall, most of this should both make conceptual sense and be unnecessary for you to ever interact with directly--but knowledge is power. A _grid_ object is a list made up of 6 components: the __x__ and __y__ locations of the grid, __data__ which will be used to store the observations that you want to grid, __interp__ that will hold the interpolated data product you generate, __grid__ that unsurprisingly are the matrix representations (i.e. 2D) of the (x,y) location pairs for the grid, and __meta__ that holds all the metadata about the grid itself.

Again, hopefully this is all detail that you never interact directly with (but you can, especially if you want to customize anything!).

### buildGrid
The arguments for the `buildGrid()` function are as follows:

```{r eval=FALSE}
buildGrid(xlim, ylim, nx, ny, x.scale, y.scale, x.factor, y.factor)
```

Both __xlim__ and __ylim__ control the spatial extent of the grid product, which for our examples were (0,1) for both the x and y axes. Then to set resolution you have the choice of either setting the number of grid cells (__nx__ and __ny__) or by setting the grid size you want (__x.scale__ and __y.sacle__). For either axis you can use either one, but if you try to use both methods the bad things might happen...

Finally there are the __x.factor__ and __y.factor__ arguments. These are a bit mysterious at first but are essentially setting the scale or units for the x and y axis, respectively. By default, both are set to 1 meaning that a change of 1 x unit is equivalent to a change of 1 y unit. The reason we need to set this is that most interpolation algorithms need to decide how far away an observation is from a given point (e.g. nearest neighbor). In most cases you don't want the end result to depend on whether you used feet or meter.

This also sets the relative length scales used. For example, if I want to estimate the temperature of the water at a given point based on observations either 10 feet from me horizontally or 10 feet below me, we would usually assume that the temperature besides me is a better guess than below me (cold water sinks). This allows us to set this relationship. Unfortunately this is one of the biggest sources of issues for qualitatively "bad" interpolations and there's not a great one-size-fits-all approach to set these values. This will likely be a topic of an entire conversation someother time.

### setGridder


### appendData


### interpData


### plotGrid
